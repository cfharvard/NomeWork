	This app is reliant on the Flask framework, whose code lives in app.py. It also uses a database, called nomework.db, which has three tables: users, classes, and times. The users table stores the users in the website. The classes table stores the classes that a user adds to their account. The times table stores the times that a user enters into the database to later be processed in the analytics page.

 	App.py includes different routes, called upon by different links across the website. To begin, the website is indexed at a login/registration page, where we prompt the user using login/register code. If the user chooses to register, they are directed to the “/register” route, where our html displays a username, password, and password confirmation input text box. We made sure that the user inputs information in every field using the ‘required’ attribute. We prevented duplicate usernames by running an SQL query on our users database. If the query returns anything, the username has already been taken. The password is stored using a hash function. Once registered, the user is directed to the login page to login.

	The website has a navbar, which is different depending on whether or not the user is logged in. If logged out, the navbar only contains the website name that is clickable and can bring you back to the login/registration page. If logged in, the navbar includes home, which is a “GET” request to route(“/”), timer, a “GET” request to route (“/timer”), analytics, a “GET” request to route(“analytics”), and logout, a button that logs the user out and returns them to the login page.

	At the login page, the user is prompted with two required input boxes of type “text”. When logging in, the user input is sent to app.py via “POST” and is used to query the database for a matching login.

	Logging in renders index.html, which serves as the users’ homepage. The classes and hours are displayed using Jinja, SQL, and html. First, app.py uses a SQL query to find the classes and their corresponding times that belong to a user. Next, those classes are returned by @app.route(“/”) into index.html, where a Jinja loop is used to generate a table displaying the user’s classes and hours timed for each class. In the event that the user mistypes the class name or no longer needs a class, there is a delete button with a drop down menu to select the class.
	
	Clicking the timer button in the navbar brings you to the timer page. The four buttons, start, stop, reset, and submit all call different functions in timer.js when clicked. Submit, the most complicated one, takes the javascript variable “seconds”, which logs the time, and creates a request to be sent to route(“/submit/<submit:seconds>”). This route calls the global variable time, which was made global so that it could be accessed by route(“/timer”), and loads the seconds variable from the Javascript into app.py. The drop down in the timer page is clicked after the user submits their time. It is used for a SQL query in route(“/timer”) to insert the user’s time, class, and current date, found by the Python function date.today(). These will be used to create charts on the analytics page.

	The analytics page has a drop down, generated by a Jinja loop using a list of classes returned from a SQL query. Clicking “Generate Graph” generates a graph with the data, which was returned via render_template into analytics.html. In analytics.html, a <script> tag holds some Javascript code that creates a chart of the user’s time history for that class using the Chart.js library.
